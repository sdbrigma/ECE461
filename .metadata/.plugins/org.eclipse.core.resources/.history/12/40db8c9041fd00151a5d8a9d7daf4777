/*
 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  ======== empty.c ========
 */
/* XDCtools Header files */
#include <xdc/std.h>
#include <xdc/runtime/System.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>

/* TI-RTOS Header files */
#include <ti/drivers/GPIO.h>
// #include <ti/drivers/I2C.h>
// #include <ti/drivers/SDSPI.h>
// #include <ti/drivers/SPI.h>
 #include <ti/drivers/UART.h>
 #include <ti/drivers/Watchdog.h>
// #include <ti/drivers/WiFi.h>

/* Board Header file */
#include "Board.h"
#include "msp.h"
#include <driverlib.h>
#include <grlib.h>
#include "Crystalfontz128x128_ST7735.h"
#include <stdio.h>
#include "functions.h"
#include "macros.h"

#define TASKSTACKSIZE   512

Task_Struct task0Struct;
Char task0Stack[TASKSTACKSIZE];
Graphics_Context g_sContext;

/*
 *  ======== heartBeatFxn ========
 *  Toggle the Board_LED0. The Task_sleep is determined by arg0 which
 *  is configured for the heartBeat Task instance.
 */
Void heartBeatFxn(UArg arg0, UArg arg1)
{
    while (1) {
        Task_sleep((UInt)arg0);
        GPIO_toggle(Board_LED0);
    }
}

/*
 * Redraw accelerometer data
 */
void drawAccelDataTask() // draw task
{
	drawAccelData();
	drawTitle();

    Task_sleep(ONE_SECOND);

}

const eUSCI_UART_Config uartConfig =
{
        EUSCI_A_UART_CLOCKSOURCE_SMCLK,          		// SMCLK Clock Source for 9600 Baud @ 48MHz
        5000,                                      	// BRDIV = 5000
        0,                                       		// UCxBRF = 0
        0,                                       		// UCxBRS = 0
        EUSCI_A_UART_NO_PARITY,                  		// No Parity
		EUSCI_A_UART_LSB_FIRST,                		// LSB First
        EUSCI_A_UART_ONE_STOP_BIT,               		// One stop bit
        EUSCI_A_UART_MODE,                       		// UART mode
		EUSCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION          // No-Oversampling
};

/*
 *  ======== main ========
 */
int main(void)
{
    Task_Params taskParams;

    /* Call board init functions */
    Board_initGeneral();
    Board_initGPIO();
    // Board_initI2C();
    // Board_initSDSPI();
     Board_initSPI();
     Board_initUART();
     Board_initWatchdog();
    // Board_initWiFi();
     Init(); // initialize challenge modules

    /* Construct heartBeat Task  thread */
    Task_Params_init(&taskParams);
    taskParams.arg0 = 1000;
    taskParams.stackSize = TASKSTACKSIZE;
    taskParams.stack = &task0Stack;
    Task_construct(&task0Struct, (Task_FuncPtr)heartBeatFxn, &taskParams, NULL);


    /* Turn on user LED */
    GPIO_write(Board_LED0, Board_LED_ON);

    System_printf("Starting the example\nSystem provider is set to SysMin. "
                  "Halt the target to view any SysMin contents in ROV.\n");
    /* SysMin will only print to the console when you call flush or exit */
    System_flush();

    /* Start BIOS */
    BIOS_start();

    return (0);
}

void UartIsr(){
	static int dataSetIndex;
	static char *dataSetASCII;
	static char *dataSetHundreds;
	static char *dataSetTens;
	static char *dataSetOnes;
	static int receiveData;
	static int dataCounter = 0;
	   uint32_t status = MAP_UART_getEnabledInterruptStatus(EUSCI_A2_BASE);

	    MAP_UART_clearInterruptFlag(EUSCI_A2_BASE, status);

	    if(status & EUSCI_A_UART_RECEIVE_INTERRUPT)
	    {
	    		receiveData = UCA2RXBUF;				//the value from the receive buffer will be placed into a receiveData variable
	    		dataSetASCII = (char*)receiveData;	//we cast this value as a char* and place into dataSetASCII
	    		if(dataSetASCII == "\n"){			//if a new line character is found,
	    			dataCounter = 3;					//send it to counter 3 location to print the number to the screen
	    		}
	    		else if (dataCounter == 0)
			{
	    			dataSetOnes = dataSetASCII;		//we save the value into the ones place
	    			dataCounter++;
			}
	    		else if (dataCounter == 1)
	    		{
	    			dataSetTens = dataSetOnes;		//we have a tens digit, so we move the first number into the tens place
	    			dataSetOnes = dataSetASCII;
	    			dataCounter++;
	    		}
	    		else if (dataCounter == 2)
	    		{
	    			dataSetHundreds = dataSetTens;	//we have a hundreds digit, so we move the second number into the hundreds place
	    			dataSetTens = dataSetOnes;
	    			dataSetOnes = dataSetASCII;
	    			dataCounter++;
	    		}
	    		else if (dataCounter == 3){
	    			dataCounter = 0;					//clear dataCounter
	    			drawData();						//write data to the display
	    			dataSetOnes = '\0';				//clear out all of our old values
	    			dataSetTens = '\0';
	    			dataSetHundreds = '\0';
	    		}
	    }
}

void ADC14Isr(){
	 uint64_t status;

	 static uint16_t resultsBuffer[3];

	    status = MAP_ADC14_getEnabledInterruptStatus();
	    MAP_ADC14_clearInterruptFlag(status);

	    /* ADC_MEM2 conversion completed */
	    if(status & ADC_INT2)
	    {
	        /* Store ADC14 conversion results */
	    		// Take running average of ADC14 values so they can be updated
			resultsBuffer[0] = ADC14_getResult(ADC_MEM0);
			resultsBuffer[1] = ADC14_getResult(ADC_MEM1);
			resultsBuffer[2] = ADC14_getResult(ADC_MEM2);

	    		/*if(avg){
	    			avg = FALSE;
	    			resultsBuffer[0] = (ADC14_getResult(ADC_MEM0) + resultsBuffer[0]) > 1;
				resultsBuffer[1] = (ADC14_getResult(ADC_MEM1) + resultsBuffer[1]) > 1;
				resultsBuffer[2] = (ADC14_getResult(ADC_MEM2) + resultsBuffer[2]) > 1;
	    		}
	    		else {
	    			avg = TRUE;
	    			resultsBuffer[0] = ADC14_getResult(ADC_MEM0);
				resultsBuffer[1] = ADC14_getResult(ADC_MEM1);
				resultsBuffer[2] = ADC14_getResult(ADC_MEM2);
	    		}*/

	        /*
	         * Draw accelerometer data on display and determine if orientation
	         * change thresholds are reached and redraw as necessary
	         */
	        if (resultsBuffer[0] < 4900) {
	            if (Lcd_Orientation != LCD_ORIENTATION_LEFT) {
	                Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_LEFT);
	                drawTitle();
	            }
	            //else
	                //drawAccelData();
	        }
	        else if (resultsBuffer[0] > 11300) {
	            if (Lcd_Orientation != LCD_ORIENTATION_RIGHT){
	                Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_RIGHT);
	                drawTitle();
	            }
	            //else
	                //drawAccelData();
	        }
	        else if (resultsBuffer[1] < 5000) {
	            if (Lcd_Orientation != LCD_ORIENTATION_UP){
	                Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_UP);
	                //drawTitle();
	            }
	            //else
	                //drawAccelData();
	        }
	        else if (resultsBuffer[1] > 11300) {
	            if (Lcd_Orientation != LCD_ORIENTATION_DOWN){
	                Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_DOWN);
	                drawTitle();
	            }
	            //else
	                //drawAccelData();
	        }
	        //else
	            //drawAccelData();
	    }
}
